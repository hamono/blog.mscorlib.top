# 远程 FPGA 虚拟实验平台网站的设计与开发

## 摘要

设计并开发了用于远程 FPGA 虚拟实验的平台网站.
该网站采用 React 框架进行开发, 使用了 antd 设计原则, 同时使用了 pwa 与并发渲染等前沿技术,
试点表明, 一方面, 用户在使用本平台进行硬件实验时具有极佳的用户体验, 另一方面, 网站的响应速度较快, 故障率较低.

## 关键词

前端, 计算机硬件, ReactJS

## 目录

- 引言
- 结构设计
  - 框架选择
  - 设计原则
  - 安全
    - xss
    - cors
    - 爬虫
- 开发
  - 埋点方案
  - diff
  - 利用缓存(pwa)
  - 复用逻辑(hook)
  - 并发渲染
  - 优化
    - 节流防抖
    - gpu 加速
- 结语
- 参考文献

## 引言

## 结构设计

## 开发

### 埋点方案

如何衡量并改善用户体验, 在版本迭代中保证网站的性能, 监控网站的稳定性, 最终达到拉新促活的目的是前端开发者首先要关注的问题.
埋点能对用户行为与网站性能进行监控和分析, 能展现出网站的不足与瓶颈, 能给工程师和决策者指明前进的方向.[1]

经过调查发现, 很多现有的方案[2]难以与 React 等现代前端框架进行很好的结合, 或具有较高的侵入性, 为了采用这些埋点方案, 很有可能要改造网站整体结构或是牺牲用户体验, 这无异于买椟还珠.
所以, 作为前端工程师, 需要设计一套适用于本实验平台的埋点方案

那么如何发送埋点数据呢? 埋点和其他数据交互不一样, 其他数据交互通常要求后端给出确切的响应结果, 而埋点是单方面的发送数据, 所以无需处理响应.
另一方面, 如果是用于异常监控的埋点, 当发送出数据时, 很有可能页面已经卡死, 崩溃, 失去响应, 这时候执行复杂的代码逻辑已经成为了奢望.

翻阅 w3c 标准, 可以发现, 标准中已经为我们提供了一个 API[3], 使用这个接口可以立即将要发送的数据放入浏览器级别的队列, 并且哪怕是在页面已经销毁的情况下仍然把数据发送出去, 为了这样的便利性, 而牺牲了获取返回值的功能, 这个接口无疑是能解决我们发送埋点数据的问题

为了监控代码性能与分析用户行为, 当代码开始执行时, 立即启动一个计时器.
执行完初始化代码逻辑, 显示加载界面, 此时进入了浏览器的事件循环, 将时间发送回去, 此为白屏时间.
当数据加载完毕, 正常显示界面, 用户可以交互时, 再次将时间发送回去, 这是可交互时间.
这两个时间决定了加载时候的用户体验, 很大程度上能够反映页面性能, 是非常重要的埋点数据.

至于如何监控稳定性和崩溃率, 首先使用 React 提供的 `componentDidCatch`[4] 处理并监控渲染期错误, 当出现错误时, 一方面需要发送数据埋点, 另一方面尝试回退数据, 修复错误, 如果无法挽回, 尝试显示用户友好的错误提示页.
无法被 React 捕获的更严重的错误使用 w3c 标准中的全局错误处理接口处理[5], 发送埋点数据, 销毁页面, 显示错误信息, 并提示用户尝试刷新解决.

## 缓存与 PWA

如何缩短加载时间, 改善用户体验? 缓存无疑是这个问题的答案. 现在最常见的缓存解决方案是利用 HTTP 协议的头部部分进行强缓存(Expires 和 Cache-Control)/协商缓存(Last-Modified 和 If-Modified-Since/ETag 和 If-None-Match) [6], 当命中缓存时, 服务端返回 304 状态码以及空的 HTTP 响应体, 浏览器就会从缓存(硬盘或是内存)中读取上一次请求的结果, 在这种情况下, 相当于少传输了一个响应体, 的确能提高加载速度.

但是, 由于这样的解决方案仍然需要与服务端建立 TCP 链接并发起请求, 如果网络状态不佳, 浏览器会选择等待服务端返回, 直至超时, 这对于用户体验无疑是毁灭性的打击, 所以我们需要一个更好的解决方案, 那就是比较先进的 PWA 方案.[7]

当启用缓存优先策略时, PWA 会尝试先返回缓存结果, 再发起请求, 当获取到服务端的响应时, 去同时更新缓存与数据, 理论上能够大大减少因等待服务端响应而产生的白屏加载时间. 举个例子, 当切换到 PWA 后, 推特提高了 65% 的响应速度, 用户发出了比以往多 75% 的推文, 降低了 20% 的用户流失率, 减少了 97% 的网络流量[8].

在实际使用过程中发现, 很多情况下, 缓存返回并且用户开始做实验时, 服务端响应才返回, 如果这时候直接热更新代码, 很有可能造成实验数据丢失以及不良的用户体验, 于是我制作了一套热更代码系统, 当缓存已经全部更新到最新版本时, 弹框询问用户是否更新, 选择是则会引起浏览器刷新并更新到最新的代码与数据.

那么在这套系统中, 应该如何判断缓存是否应该更新呢? 一个优秀的解法就是把哈希值作为文件名, 当文件内容改变, 则文件名必然改变, 当文件名改变, 就意味着需要更新缓存, 同时也正好规避了 HTTP 头部缓存策略, 避免其对 PWA 缓存系统造成干扰. 但是, 有些文件因为被其他系统所依赖, 所以不方面每次都改名. 所以选择在编译时将其哈希值存储在代码中, 当收到响应时, 将响应哈希值与其对比, 作为判断依据. 通过这样设计, 有效的防止了不必要的缓存更新, 避免了经常性的弹框打扰用户.

## 结语

## 参考文献

[1] 黎灿灿. 基于 html5 的用户行为分析及性能监控方法研究[D].  
[2] 张鑫. 一种监测网站的页面埋点的方法和装置.  
[3] <https://w3c.github.io/beacon/#sec-sendBeacon-method>  
[4] <https://reactjs.org/docs/react-component.html#componentdidcatch>  
[5] <https://html.spec.whatwg.org/multipage/webappapis.html#handler-onerror>
[6] <https://tools.ietf.org/html/rfc7234>
[7] Hume D . Progressive Web Apps[J]. Computer active, 2018(523):49-49.
[8] <https://web.dev/what-are-pwas/#the-best-of-both-worlds>
