# 斐波那契数列

*斐波那契数列*（意大利语：Successione di Fibonacci），又译为*菲波拿契数列*、*菲波那西数列*、*斐波那契数列*、*黄金分割数列*。

在数学上，费波那契数列是以递归的方法来定义：

- f(0) = 0
- f(1) = 1
- f(n) = f(n-1) + f(n-2)

用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是：

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……

> 特别指出：0不是第一项，而是第零项。

## 传统方法

计算斐波那契数列（Fibonacci polynomial）的一个最基础的算法是，直接按照定义计算（函数递归）：
```typescript
const fib = (n: number): number => {
  if (n === 0 || n === 1) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}
```

当n=5时，fib(5)的计算过程如下:
1. `fib(5)`
2. `fib(4) + fib(3)`
3. `(fib(3) + fib(2)) + (fib(2) + fib(1))`
4. `((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))`
5. `(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))`

由上面可以看出，这种算法对于相似的子问题进行了重复的计算，因此不是一种高效的算法。实际上，该算法的运算时间是指数级增长的。 

## 动态规划

改进的方法是，我们可以通过保存已经算出的子问题的解来避免重复计算：

```typescript
const array: number[] = [0, 1];

const fib = (n: number): number => {
  if (!(n in array)) {
    array[n] = fib(n - 1) + fib(n - 2);
  }
  return array[n];
}
```

将前n个已经算出的数保存在数组`array`中，这样在后面的计算中可以直接应用前面的结果，从而避免了重复计算。算法的运算时间变为`O(n)`