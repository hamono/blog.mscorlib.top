# 远程 FPGA 虚拟实验平台网站的设计与开发

## 摘要

设计并开发了用于远程 FPGA 虚拟实验的平台网站.
该网站采用 React 框架进行开发, 使用了 antd 设计原则, 同时使用了 pwa 与并发渲染等前沿技术,
试点表明, 一方面, 用户在使用本平台进行硬件实验时具有极佳的用户体验, 另一方面, 网站的响应速度较快, 故障率较低.

## 关键词

前端, 计算机硬件, ReactJS

## 目录

- 引言
- 结构设计
  - 框架选择
  - 设计原则
  - 安全
    - xss
    - cors
    - 爬虫
- 开发
  - 埋点方案
  - 缓存与 pwa
  - diff 与性能优化
  - 复用逻辑(hook)
  - 并发渲染
  - 优化
    - 节流防抖
    - gpu 加速
- 结语
- 参考文献

## 引言

## 结构设计

## 开发

### 埋点方案

如何衡量并改善用户体验, 在版本迭代中保证网站的性能, 监控网站的稳定性, 最终达到拉新促活的目的是前端开发者首先要关注的问题.
埋点能对用户行为与网站性能进行监控和分析, 能展现出网站的不足与瓶颈, 能给工程师和决策者指明前进的方向.[1]

经过调查发现, 很多现有的方案[2]难以与 React 等现代前端框架进行很好的结合, 或具有较高的侵入性, 为了采用这些埋点方案, 很有可能要改造网站整体结构或是牺牲用户体验, 这无异于买椟还珠.
所以, 作为前端工程师, 需要设计一套适用于本实验平台的埋点方案

那么如何发送埋点数据呢? 埋点和其他数据交互不一样, 其他数据交互通常要求后端给出确切的响应结果, 而埋点是单方面的发送数据, 所以无需处理响应.
另一方面, 如果是用于异常监控的埋点, 当发送出数据时, 很有可能页面已经卡死, 崩溃, 失去响应, 这时候执行复杂的代码逻辑已经成为了奢望.

翻阅 w3c 标准, 可以发现, 标准中已经为这类情况提供了一个 API[3], 使用这个接口可以立即将要发送的数据放入浏览器级别的队列, 并且哪怕是在页面已经销毁的情况下仍然把数据发送出去, 为了这样的便利性, 而牺牲了获取返回值的功能, 这个接口无疑是能解决发送埋点数据的问题

为了监控代码性能与分析用户行为, 当代码开始执行时, 立即启动一个计时器.
执行完初始化代码逻辑, 显示加载界面, 此时进入了浏览器的事件循环, 将时间发送回去, 此为白屏时间.
当数据加载完毕, 正常显示界面, 用户可以交互时, 再次将时间发送回去, 这是可交互时间.
这两个时间决定了加载时候的用户体验, 很大程度上能够反映页面性能, 是非常重要的埋点数据.

至于如何监控稳定性和崩溃率, 首先使用 React 提供的 `componentDidCatch`[4] 处理并监控渲染期错误, 当出现错误时, 一方面需要发送数据埋点, 另一方面尝试回退数据, 修复错误, 如果无法挽回, 尝试显示用户友好的错误提示页.
无法被 React 捕获的更严重的错误使用 w3c 标准中的全局错误处理接口处理[5], 发送埋点数据, 销毁页面, 显示错误信息, 并提示用户尝试刷新解决.

### 缓存与 PWA

如何缩短加载时间, 改善用户体验? 缓存无疑是这个问题的答案. 现在最常见的缓存解决方案是利用 HTTP 协议的头部部分进行强缓存(Expires 和 Cache-Control)/协商缓存(Last-Modified 和 If-Modified-Since/ETag 和 If-None-Match) [6], 当命中缓存时, 服务端返回 304 状态码以及空的 HTTP 响应体, 浏览器就会从缓存(硬盘或是内存)中读取上一次请求的结果, 在这种情况下, 相当于少传输了一个响应体, 的确能提高加载速度.

但是, 由于这样的解决方案仍然需要与服务端建立 TCP 链接并发起请求, 如果网络状态不佳, 浏览器会选择等待服务端返回, 直至超时, 这对于用户体验无疑是毁灭性的打击, 所以急需一个更好的解决方案, 那就是比较先进的 PWA 方案.[7]

当启用缓存优先策略时, PWA 会尝试先返回缓存结果, 再发起请求, 当获取到服务端的响应时, 去同时更新缓存与数据, 理论上能够大大减少因等待服务端响应而产生的白屏加载时间. 举个例子, 当切换到 PWA 后, 推特提高了 65% 的响应速度, 用户发出了比以往多 75% 的推文, 降低了 20% 的用户流失率, 减少了 97% 的网络流量[8].

在实际使用过程中发现, 很多情况下, 缓存返回并且用户开始做实验时, 服务端响应才返回, 如果这时候直接热更新代码, 很有可能造成实验数据丢失以及不良的用户体验, 于是笔者制作了一套热更代码系统, 当缓存已经全部更新到最新版本时, 弹框询问用户是否更新, 选择是则会引起浏览器刷新并更新到最新的代码与数据.

那么在这套系统中, 应该如何判断缓存是否应该更新呢? 一个优秀的解法就是把哈希值作为文件名, 当文件内容改变, 则文件名必然改变, 当文件名改变, 就意味着需要更新缓存, 同时也正好规避了 HTTP 头部缓存策略, 避免其对 PWA 缓存系统造成干扰. 但是, 有些文件因为被其他系统所依赖, 所以不方面每次都改名. 所以选择在编译时将其哈希值存储在代码中, 当收到响应时, 将响应哈希值与其对比, 作为判断依据. 通过这样设计, 有效的防止了不必要的缓存更新, 避免了经常性的弹框打扰用户.

### diff 与性能优化

本实验平台具有画布系统, 用户可以将实验器材拖拽到画布上进行排列组合. 在试点过程中, 埋点数据表明, 当画布上器材数较多时, 容易引起卡顿. 为了进行性能优化, 笔者去研究了 react 的 diff 策略[9]

传统的树形结构 diff 算法是 O(n^3) 的复杂度[10][11], 而 react 所采用的 diff 算法是 O(n) 的复杂度. 为了降低复杂度, 加快执行速度, react 做了一个非常大胆的假设: 在 dom 中, 跨层级的移动非常少, 可以忽略不计. 于是 react 在做树形结构的比较时, 仅会比较同级结构, 一旦产生了跨层级的结点移动, react 就会选择放弃比较, 在原层级销毁结点, 在目标层级重建结点. 虽然在这种情况下复杂度提高了, 但是在其他绝大多数情况下复杂度都得到了明显的降低.

同时, 由于 react 选择了组件化的开发模式, react 假定, 相同的组件返回相似的虚拟 dom 结构, 不同的组件返回不同的虚拟 dom 结构, 所以, 当组件不同时, react 会选择放弃 diff, 销毁原有组件, 新建目标组件, 同样也是一种放弃极端情况而取得性能优化的手段[12]

最后, 对于处于同一层级下的多个结点, react 允许开发人员对其分别添加唯一的标识符, 通过判断标识符, react 可以非常方便快速的定位到应该如何对结点进行操作, 从而有效避免了仅仅因为位置移动而产生的低效销毁重建操作.

知道了 react 的 diff 原理, 就可以方便的进行针对性的优化手段: 一方面, 在拖拽实验器材时, 避免跨层级的结点移动, 而是选择将数据记录在一个数组中, 最后将数组映射到 dom 上, 另一方面, 在数组映射到 dom 时, 为其添加唯一的标识符, 方便 react 对其进行针对性的高效操作. 之后的埋点数据表明, 卡顿得到了明显的好转.

### hook 与逻辑复用

本实验系统中有许多不同的实验器材, 每个实验器材都有着相似的拖拽逻辑. 为了提高代码的可维护性, 必然要复用这些逻辑, 然而常见的逻辑复用方案难以影响到 react 组件的生命周期[13], 例如, 传统的逻辑复用方案难以解决每个实验器材在挂载时需要去获取自身的大小位置等参数的问题.

为了解决这个问题, 需要引入一种名为 hook 的新技术, 顾名思义, hook 能钩住 react 组件的生命周期, 使开发人员能够方便的在组件挂载或是销毁时复用相似的逻辑.

笔者有幸参与了 fre[14] 中 hook 的设计, 在这里和大家分享下 hook 的原理. hook 分为两种类型, 一种是值类型, 返回一个值, 当开发人员去改变这个值时, 对应的组件将引起重绘(rerender), 另一种是函数类型, 当触发挂载, 销毁等 react 组件生命周期, 抑或是需要监听某个值发生改变, 就会执行对应的函数与逻辑. 而这两种 hook 均具有原语性(primitive), 可以将其排列组合成特定的业务逻辑.

在执行的过程中, 每个结点会拥有一个自己的计数器和 hook 数组, 当开始渲染时, 计数器清零, 每调用一个 hook, 计数器自增, 并且把 hook 数组中计数器所对应的项设为不同 hook 所对应的值, 值类型是返回值和改变这个值的函数, 函数类型是函数和触发这个函数的条件, 并且在相应的时机触发这些函数.

这样设计的好处在于, 不同组件之间的逻辑不会相互冲突, 提高了可复用性和可维护性, 缺陷在于, 由于计数器的设计, 导致如果在分支, 循环, 条件语句中使用 hook, 可能会导致难以预料的后果.

在迁移至 hook 后, 一方面, 代码看起来干净整洁, 可维护性得到了提高, 另一方面, 打包体积缩小了近 20%, 间接的提高了加载速度.

### 竞速问题, 闪屏问题与并发模式

在本实验平台中, 有一个带有分页器的实验列表, 用户可以选择参加实验列表中的实验. 通过数据埋点发现, 少数情况下, 用户已经请求了第三页的实验列表, 却仍然进行了第二页的实验. 经过深入调研发现, 有时候由于网络因素, 第二页的数据会比第三页的数据晚抵达, 而数据驱动界面, 所以会存在位于第三页看到的却是第二页的数据的情况. 这就是竞速问题(race problem) [15], 当一个系统的输出依赖时间等不可控因素时, 可能会导致一些难以预料的问题[16].

同时, 如果网络状态足够好, 用户会看到加载界面一闪而过, 因为数据驱动界面, 当下一页的数据还没有获取时, 界面是不存在的, 即白屏, 一个优秀的选择是显示加载界面, 但是加载界面一闪而过会造成不良的用户体验, 从而使用户产生一种"刚刚是不是错过什么东西"的干净, 这就是闪屏问题.

为了解决这两个问题, 笔者启用了并发模式(concurrent mode)来进行渲染. 为了解释什么是并发模式, 需要拿类似于 git 的版本控制系统来举例[17], 一般存在名为 master 的主分支, 当需要引入新功能时, 通常会新建一个分支, 当新功能完成, 便会把这个分支合并进 master 分支. 在前端的并发模式中, 当需要切换页面时, 比如实验列表切换分页, 原分支进入 loading 状态, 同时新建一个分支在后台渲染并加载数据, 当数据完全加载完成, 就会合并进原分支. 由于仅会存在一个新分支, 在时间线上, 更晚建立的分支会直接覆盖掉之前建立的分支, 通过这样设计就能有效避免竞速问题的产生. 另一方面, 在超时之前, 用户仅会看到原分支, 而不是正在加载的新分支, 这样同时也解决了闪屏问题.

## 结语

## 参考文献

[1] 黎灿灿. 基于 html5 的用户行为分析及性能监控方法研究[D].  
[2] 张鑫. 一种监测网站的页面埋点的方法和装置.  
[3] <https://w3c.github.io/beacon/#sec-sendBeacon-method>  
[4] <https://reactjs.org/docs/react-component.html#componentdidcatch>  
[5] <https://html.spec.whatwg.org/multipage/webappapis.html#handler-onerror>  
[6] <https://tools.ietf.org/html/rfc7234>  
[7] Hume D . Progressive Web Apps[J]. Computer active, 2018(523):49-49.  
[8] <https://web.dev/what-are-pwas/#the-best-of-both-worlds>  
[9] 严新巧, 白俊峰. 基于 Dom Diff 算法分析 React 刷新机制[J]. 电脑知识与技术(18).  
[10] Lee S K, Dong A K. X-Tree Diff+: Efficient Change Detection Algorithm in XML Documents[J]. 2006, 4096:1037-1046.  
[11] Bille P . A survey on tree edit distance and related problems[J]. Theoretical Computer Science, 2005, 337(1-3):217-239.  
[12] <https://reactjs.org/docs/reconciliation.html>  
[13] 罗海丽[1]. IOC／DI 原理浅析[J]. 中国高新技术企业, 2008(17).  
[14] <https://github.com/yisar/fre>  
[15] Unger, S.H. (June 1995). "Hazards, Critical Races, and Metastability". IEEE Transactions on Computers. 44 (6): 754–768.  
[16] A race condition when handling socket errors can lead to an assertion failure in resolver.c. Internet Systems Consortium. Retrieved 5 June 2017.  
[17] Loeliger J, Mccullough M. Version Control with Git: Powerful Tools and Techniques for Collaborative Software Development[D]. 2012.
