# 远程 FPGA 虚拟实验平台网站的设计与开发

## 摘要

设计并开发了用于远程 FPGA 虚拟实验的平台网站.
该网站采用 React 框架进行开发, 使用了 antd 设计原则, 同时使用了 pwa 与并发渲染等前沿技术,
试点表明, 一方面, 用户在使用本平台进行硬件实验时具有极佳的用户体验, 另一方面, 网站的响应速度较快, 故障率较低.

## 关键词

前端, 计算机硬件, ReactJS

## 目录

- 引言
- 结构设计
  - 框架选择
  - 设计原则
  - 安全
    - xss
    - cors
    - 爬虫
- 开发
  - 埋点方案
  - 缓存与 pwa
  - diff 与性能优化
  - 复用逻辑(hook)
  - 并发渲染
  - 优化
    - 节流防抖
    - gpu 加速
- 结语
- 参考文献

## 引言

## 结构设计

## 开发

### 埋点方案

如何衡量并改善用户体验, 在版本迭代中保证网站的性能, 监控网站的稳定性, 最终达到拉新促活的目的是前端开发者首先要关注的问题.
埋点能对用户行为与网站性能进行监控和分析, 能展现出网站的不足与瓶颈, 能给工程师和决策者指明前进的方向.[1]

经过调查发现, 很多现有的方案[2]难以与 React 等现代前端框架进行很好的结合, 或具有较高的侵入性, 为了采用这些埋点方案, 很有可能要改造网站整体结构或是牺牲用户体验, 这无异于买椟还珠.
所以, 作为前端工程师, 需要设计一套适用于本实验平台的埋点方案

那么如何发送埋点数据呢? 埋点和其他数据交互不一样, 其他数据交互通常要求后端给出确切的响应结果, 而埋点是单方面的发送数据, 所以无需处理响应.
另一方面, 如果是用于异常监控的埋点, 当发送出数据时, 很有可能页面已经卡死, 崩溃, 失去响应, 这时候执行复杂的代码逻辑已经成为了奢望.

翻阅 w3c 标准, 可以发现, 标准中已经为这类情况提供了一个 API[3], 使用这个接口可以立即将要发送的数据放入浏览器级别的队列, 并且哪怕是在页面已经销毁的情况下仍然把数据发送出去, 为了这样的便利性, 而牺牲了获取返回值的功能, 这个接口无疑是能解决发送埋点数据的问题

为了监控代码性能与分析用户行为, 当代码开始执行时, 立即启动一个计时器.
执行完初始化代码逻辑, 显示加载界面, 此时进入了浏览器的事件循环, 将时间发送回去, 此为白屏时间.
当数据加载完毕, 正常显示界面, 用户可以交互时, 再次将时间发送回去, 这是可交互时间.
这两个时间决定了加载时候的用户体验, 很大程度上能够反映页面性能, 是非常重要的埋点数据.

至于如何监控稳定性和崩溃率, 首先使用 React 提供的 `componentDidCatch`[4] 处理并监控渲染期错误, 当出现错误时, 一方面需要发送数据埋点, 另一方面尝试回退数据, 修复错误, 如果无法挽回, 尝试显示用户友好的错误提示页.
无法被 React 捕获的更严重的错误使用 w3c 标准中的全局错误处理接口处理[5], 发送埋点数据, 销毁页面, 显示错误信息, 并提示用户尝试刷新解决.

### 缓存与 PWA

如何缩短加载时间, 改善用户体验? 缓存无疑是这个问题的答案. 现在最常见的缓存解决方案是利用 HTTP 协议的头部部分进行强缓存(Expires 和 Cache-Control)/协商缓存(Last-Modified 和 If-Modified-Since/ETag 和 If-None-Match) [6], 当命中缓存时, 服务端返回 304 状态码以及空的 HTTP 响应体, 浏览器就会从缓存(硬盘或是内存)中读取上一次请求的结果, 在这种情况下, 相当于少传输了一个响应体, 的确能提高加载速度.

但是, 由于这样的解决方案仍然需要与服务端建立 TCP 链接并发起请求, 如果网络状态不佳, 浏览器会选择等待服务端返回, 直至超时, 这对于用户体验无疑是毁灭性的打击, 所以急需一个更好的解决方案, 那就是比较先进的 PWA 方案.[7]

当启用缓存优先策略时, PWA 会尝试先返回缓存结果, 再发起请求, 当获取到服务端的响应时, 去同时更新缓存与数据, 理论上能够大大减少因等待服务端响应而产生的白屏加载时间. 举个例子, 当切换到 PWA 后, 推特提高了 65% 的响应速度, 用户发出了比以往多 75% 的推文, 降低了 20% 的用户流失率, 减少了 97% 的网络流量[8].

在实际使用过程中发现, 很多情况下, 缓存返回并且用户开始做实验时, 服务端响应才返回, 如果这时候直接热更新代码, 很有可能造成实验数据丢失以及不良的用户体验, 于是笔者制作了一套热更代码系统, 当缓存已经全部更新到最新版本时, 弹框询问用户是否更新, 选择是则会引起浏览器刷新并更新到最新的代码与数据.

那么在这套系统中, 应该如何判断缓存是否应该更新呢? 一个优秀的解法就是把哈希值作为文件名, 当文件内容改变, 则文件名必然改变, 当文件名改变, 就意味着需要更新缓存, 同时也正好规避了 HTTP 头部缓存策略, 避免其对 PWA 缓存系统造成干扰. 但是, 有些文件因为被其他系统所依赖, 所以不方面每次都改名. 所以选择在编译时将其哈希值存储在代码中, 当收到响应时, 将响应哈希值与其对比, 作为判断依据. 通过这样设计, 有效的防止了不必要的缓存更新, 避免了经常性的弹框打扰用户.

### diff 与性能优化

本实验平台具有画布系统, 用户可以将实验器材拖拽到画布上进行排列组合. 在试点过程中, 埋点数据表明, 当画布上器材数较多时, 容易引起卡顿. 为了进行性能优化, 笔者去研究了 react 的 diff 策略[9]

传统的树形结构 diff 算法是 O(n^3) 的复杂度[10][11], 而 react 所采用的 diff 算法是 O(n) 的复杂度. 为了降低复杂度, 加快执行速度, react 做了一个非常大胆的假设: 在 dom 中, 跨层级的移动非常少, 可以忽略不计. 于是 react 在做树形结构的比较时, 仅会比较同级结构, 一旦产生了跨层级的结点移动, react 就会选择放弃比较, 在原层级销毁结点, 在目标层级重建结点. 虽然在这种情况下复杂度提高了, 但是在其他绝大多数情况下复杂度都得到了明显的降低.

同时, 由于 react 选择了组件化的开发模式, react 假定, 相同的组件返回相似的虚拟 dom 结构, 不同的组件返回不同的虚拟 dom 结构, 所以, 当组件不同时, react 会选择放弃 diff, 销毁原有组件, 新建目标组件, 同样也是一种放弃极端情况而取得性能优化的手段[12]

最后, 对于处于同一层级下的多个结点, react 允许开发人员对其分别添加唯一的标识符, 通过判断标识符, react 可以非常方便快速的定位到应该如何对结点进行操作, 从而有效避免了仅仅因为位置移动而产生的低效销毁重建操作.

知道了 react 的 diff 原理, 就可以方便的进行针对性的优化手段: 一方面, 在拖拽实验器材时, 避免跨层级的结点移动, 而是选择将数据记录在一个数组中, 最后将数组映射到 dom 上, 另一方面, 在数组映射到 dom 时, 为其添加唯一的标识符, 方便 react 对其进行针对性的高效操作. 之后的埋点数据表明, 卡顿得到了明显的好转.

## 结语

## 参考文献

[1] 黎灿灿. 基于 html5 的用户行为分析及性能监控方法研究[D].  
[2] 张鑫. 一种监测网站的页面埋点的方法和装置.  
[3] <https://w3c.github.io/beacon/#sec-sendBeacon-method>  
[4] <https://reactjs.org/docs/react-component.html#componentdidcatch>  
[5] <https://html.spec.whatwg.org/multipage/webappapis.html#handler-onerror>  
[6] <https://tools.ietf.org/html/rfc7234>  
[7] Hume D . Progressive Web Apps[J]. Computer active, 2018(523):49-49.  
[8] <https://web.dev/what-are-pwas/#the-best-of-both-worlds>  
[9] 严新巧, 白俊峰. 基于 Dom Diff 算法分析 React 刷新机制[J]. 电脑知识与技术(18).  
[10] Lee S K, Dong A K. X-Tree Diff+: Efficient Change Detection Algorithm in XML Documents[J]. 2006, 4096:1037-1046.  
[11] Bille P . A survey on tree edit distance and related problems[J]. Theoretical Computer Science, 2005, 337(1-3):217-239.  
[12] <https://reactjs.org/docs/reconciliation.html>
